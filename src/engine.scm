(declare (unit engine)
         (uses stack))

(import (srfi 69))

(define (engine-execute program labels)
  (define (program-ref i) (vector-ref program i))
  (define (labels-ref k) (hash-table-ref labels k))

  (define stack (make-stack)) ; data stack
  (define pc 0)               ; program counter
  (define flag 0)             ; flag used by comp and jumps

  (define (inst-push!)
    (set! stack (stack-push stack (program-ref (+ pc 1))))
    (set! pc (+ pc 2)))

  (define (inst-pop!)
    (when (< (stack-length stack) 1)
      (engine-error 'stack "too few elements in stack"))
    (set! stack (stack-pop stack))
    (set! pc (+ pc 1)))

  (define (inst-dup!)
    (when (< (stack-length stack) 1)
      (engine-error 'stack "too few elements in stack"))
    (set! stack (stack-push stack (stack-top stack)))
    (set! pc (+ pc 1)))

  (define (inst-swap!)
    (when (< (stack-length stack) 2)
      (engine-error 'stack "too few elements in stack"))
    (let ((e1 (stack-ref stack 0))
          (e2 (stack-ref stack 1)))
      (set! stack (stack-drop stack 2))
      (set! stack (stack-push stack e1 e2)))
    (set! pc (+ pc 1)))

  (define (inst-rot!)
    (when (< (stack-length stack) 3)
      (engine-error 'stack "too few elements in stack"))
    (let ((e1 (stack-ref stack 0))
          (e2 (stack-ref stack 1))
          (e3 (stack-ref stack 2)))
      (set! stack (stack-drop stack 3))
      (set! stack (stack-push stack e2 e1 e3)))
    (set! pc (+ pc 1)))

  (define (inst-arithmetic! proc)
    (when (< (stack-length stack) 2)
      (engine-error 'stack "too few elements in stack"))
    (let ((n1 (stack-ref stack 0))
          (n2 (stack-ref stack 1)))
      (unless (and (number? n1) (number? n2))
        (engine-error 'type "expected two numbers"))
      (set! stack (stack-drop stack 2))
      (set! stack (stack-push stack (eval `(,proc ,n2 ,n1)))))
    (set! pc (+ pc 1)))

  (define (inst-comp!)
    (when (< (stack-length stack) 2)
      (engine-error 'stack "too few elements in stack"))
    (let ((n1 (stack-ref stack 0))
          (n2 (stack-ref stack 1)))
      (unless (and (number? n1) (number? n2))
        (engine-error 'type "expected two numbers"))
      (cond ((< n2 n1) (set! flag -1))
            ((> n2 n1) (set! flag 1))
            (else (set! flag 0))))
    (set! stack (stack-drop stack 2))
    (set! pc (+ pc 1)))

  (define (inst-jump!)
    (set! pc (labels-ref (program-ref (+ pc 1)))))

  (define (inst-conditional-jump! targ)
    (if (= targ flag)
        (set! pc (labels-ref (program-ref (+ pc 1))))
        (set! pc (+ pc 2))))

  (define (inst-read!)
    (set! stack (stack-push stack (read-char)))
    (set! pc (+ pc 1)))

  (define (inst-write!)
    (when (< (stack-length stack) 1)
      (engine-error 'stack "too few elements in stack"))
    (display (stack-top stack))
    (set! stack (stack-pop stack))
    (set! pc (+ pc 1)))

  (define (inst-newline!)
    (newline)
    (set! pc (+ pc 1)))

  (define inst-exit exit)

  (do () ((>= pc (vector-length program)))
    (case (program-ref pc)
      ((push) (inst-push!))
      ((pop) (inst-pop!))
      ((dup) (inst-dup!))
      ((swap) (inst-swap!))
      ((rot) (inst-rot!))
      ((add) (inst-arithmetic! '+))
      ((sub) (inst-arithmetic! '-))
      ((mul) (inst-arithmetic! '*))
      ((div) (inst-arithmetic! '/))
      ((comp) (inst-comp!))
      ((jump) (inst-jump!))
      ((jumpe) (inst-conditional-jump! 0))
      ((jumpl) (inst-conditional-jump! -1))
      ((jumpg) (inst-conditional-jump! 1))
      ((read) (inst-read!))
      ((write) (inst-write!))
      ((newline) (inst-newline!))
      ((exit) (inst-exit)))))
