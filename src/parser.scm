(declare (unit parser)
         (uses error)
         (uses global)
         (uses token))

(import (srfi 69))

(define program '())
(define labels '())
(define address 0)

(define line-number 0)

(define (valid-directive? dir) (memq dir (directives)))
(define (valid-instruction? inst) (assq inst (instructions)))

(define (operand-count inst)
  (cdr (assq inst (instructions))))

(define (program-cons! elem)
  (set! program (cons elem program))
  (set! address (+ address 1)))

(define (labels-cons! lab)
  (set! labels (cons (cons lab address) labels)))

(define (parse-directive! tokens)
  (define dir (token/data->symbol (car tokens)))
  (unless (null? (cdr tokens)) (parser-error "tokens trailing directive"))
  (unless (valid-directive? dir) (parser-error "invalid directive"))
  (program-cons! dir))

(define (parse-label! tokens)
  (define lab (token/data->symbol (car tokens)))
  (when (assq lab labels)
    (parser-error "duplicate label"))
  (let* ((lab-str (symbol->string lab))
         (lab-name (substring lab-str 0 (- (string-length lab-str) 1)))
         (loc-syn (string->symbol (string-append ":" lab-name))))
    (labels-cons! loc-syn))
  (unless (null? (cdr tokens))
    (parse-expression! (cdr tokens))))

(define (parse-expression! tokens)
  (if (token-instruction? (car tokens))
      (let ((inst (token/instruction->symbol (car tokens))))
        (unless (valid-instruction? inst)
          (parser-error "invalid instruction"))
        (unless (= (length (cdr tokens)) (operand-count inst))
          (parser-error "invalid number of operands"))
        (program-cons! inst)
        (for-each (lambda (tok)
                    (if (token-operand? tok)
                        (program-cons! (token/operand->value tok))
                        (parser-error "invalid operand")))
                  (cdr tokens)))
      (if (null? (cdr tokens))
          (program-cons! (token/immediate->value (car tokens)))
          (parser-error "tokens trailing immediate"))))

(define (parse-line! tokens)
  (set! line-number (+ line-number 1))
  (cond ((null? tokens))
        ((token-directive? (car tokens)) (parse-directive! tokens))
        ((token-label? (car tokens)) (parse-label! tokens))
        (else (parse-expression! tokens))))

(define (parse-tokens tokens)
  (for-each parse-line! tokens)
  (cons (list->vector (reverse program))
        (alist->hash-table (reverse labels))))
